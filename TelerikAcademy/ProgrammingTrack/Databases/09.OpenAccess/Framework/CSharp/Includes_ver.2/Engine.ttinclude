<#+
public class Engine : TelerikTextTransformationBase
{
	protected const string ClassGeneratorFile = "ClassGenerator.ttinclude";
	protected const string ContextGeneratorFile = "ContextGenerator.ttinclude";
	protected const string InterfacesGeneratorFile = "InterfacesGenerator.ttinclude";
	protected const string FluentMappingGeneratorFile = "FluentMappingGenerator.ttinclude";
	protected Template template;

	public Engine(Template template) : base(template.RootGenerator)
    {
		this.template = template;
	}

	public void RunCodeGeneration()
    {
		// common header
		this.template.TemplateContext.StartHeader();
		// the code here will be applied at the beginning of each generated file.
		this.template.DocumentationGenerator.GenerateFileBlockHeader();
		this.template.TemplateContext.EndBlock(); 
		
		if (this.template.Model.ShouldGenerateStandaloneUsings)
		{
			this.template.DocumentationGenerator.GenerateAutoGeneratedMessage(Engine.ClassGeneratorFile);
			this.template.UsingsGenerator.GenerateUsings(this.template.Model.AllUsings);
		}
		
		// context generation
		if (this.template.ShouldGenerateContext)
		{
			bool isOneTimeFluentGeneration = string.IsNullOrEmpty(this.template.ContextFileName) == false;

			if(isOneTimeFluentGeneration)
            {
				string fileName = Path.ChangeExtension(this.template.Model.ContextClass.Name, this.template.DefaultExtension);
				this.template.TemplateContext.StartNewFileBlock(fileName, this.template.Model.ContextClass.Namespace, this.template.ContextFileName); 
			}

			this.template.DocumentationGenerator.GenerateAutoGeneratedMessage(Engine.ContextGeneratorFile);
			this.template.UsingsGenerator.GenerateUsings(this.template.Model.ContextClass);
			bool hasNamespace = this.template.NamespaceGenerator.GenerateNamespaceStartBlock(this.template.Model.ContextClass);
			if (hasNamespace)
			{
				this.PushIndent("\t");
			}
			
			this.template.ContextGenerator.GenerateContextClass(this.template.Model.ContextClass);
			this.template.InterfacesGenerator.GenerateInterface(this.template.Model.ContextClass.IUnitOfWorkInterface);
			if (hasNamespace)
			{
				this.PopIndent();
				this.template.NamespaceGenerator.GenerateNamespaceEndBlock();
			}

			if(isOneTimeFluentGeneration)
            {
				this.template.TemplateContext.EndBlock();
            }
		}
		// if an empty context file will be generated
        else if(this.template.GenerateMultipleFiles)
        {
			this.template.DocumentationGenerator.GenerateComments("The context generation is currently disabled. It can be enabled from the Model Settings dialog, available from the context menu of the Visual Designer.", "In order to do that, check the Generate Context option in the Code Generation tab.");
        }
		
		// classes generation
		foreach(Telerik.OpenAccess.CodeGeneration.CodeNamespace @namespace in this.template.Model.Namespaces)
		{
			foreach(Telerik.OpenAccess.CodeGeneration.CodeClass @class in @namespace.Classes)
			{
				string fileName = Path.ChangeExtension(@class.Name, this.template.DefaultExtension);
				this.template.TemplateContext.StartNewFileBlock(fileName, @class.Namespace); 
				if (this.template.GenerateMultipleFiles)
				{
					this.template.DocumentationGenerator.GenerateAutoGeneratedMessage(Engine.ClassGeneratorFile);
					this.template.UsingsGenerator.GenerateUsings(@class);
				}
		
				bool hasNamespace = this.template.NamespaceGenerator.GenerateNamespaceStartBlock(@class);
				if (hasNamespace)
				{
					this.PushIndent("\t");
				}
		
				this.template.ClassGenerator.GenerateClass(@class);
				if (hasNamespace)
				{
					this.PopIndent();
					this.template.NamespaceGenerator.GenerateNamespaceEndBlock();
				}
				
				this.template.TemplateContext.EndBlock();
			}
			
			// interfaces generation
			foreach(Telerik.OpenAccess.CodeGeneration.CodeInterface @interface in @namespace.Interfaces)
			{
				string fileName = Path.ChangeExtension(@interface.Name, this.template.DefaultExtension);
				this.template.TemplateContext.StartNewFileBlock(fileName, @interface.Namespace); 
				if (this.template.GenerateMultipleFiles)
				{
					this.template.DocumentationGenerator.GenerateAutoGeneratedMessage(Engine.InterfacesGeneratorFile);
					this.template.UsingsGenerator.GenerateUsings(@interface);
				}
		
				bool hasNamespace = this.template.NamespaceGenerator.GenerateNamespaceStartBlock(@interface);
				if (@interface.IsInterface)
				{
					if (hasNamespace)
					{
						this.PushIndent("\t");
					}
		
					this.template.InterfacesGenerator.GenerateInterface(@interface);
					if (hasNamespace)
					{
						this.PopIndent();
						this.template.NamespaceGenerator.GenerateNamespaceEndBlock();
					}
				}
		
				this.template.TemplateContext.EndBlock();
			}
		}
		
		// fluent mapping generation
		MappingDefinitionType mappingDefinitionType = this.template.Model.ModelSettings.CodeGenerationSettings.MappingDefinitionType;
		if((mappingDefinitionType & MappingDefinitionType.Fluent) == MappingDefinitionType.Fluent)
		{
			string fileName = Path.ChangeExtension(this.template.Model.FluentMappingClass.Name, ".cs");
			this.template.TemplateContext.StartNewFileBlock(fileName, this.template.Model.ContextClass.Namespace);
			if (this.template.GenerateMultipleFiles)
			{
				this.template.DocumentationGenerator.GenerateAutoGeneratedMessage(Engine.FluentMappingGeneratorFile); 
			}
		
			this.template.FluentMappingGenerator.GenerateFluentMetadataSource(this.template.Model.FluentMappingClass, 
				this.template.MetaModel, this.template.GenerateMultipleFiles);
			this.template.TemplateContext.EndBlock();
		}
		
		// common footer
		this.template.TemplateContext.StartFooter();
		// the code here will be applied at the end of each generated file.
		this.template.DocumentationGenerator.GenerateFileBlockFooter();
		this.template.TemplateContext.EndBlock(); 
		
		// generate files
		if(this.template.OverwriteExistingFiles.HasValue)
        {
			this.template.TemplateContext.Process(this.template.GenerateMultipleFiles, this.template.CodeGenerationPath, this.template.OverwriteExistingFiles.Value);
		}
		else
        {
			this.template.TemplateContext.Process(this.template.GenerateMultipleFiles, this.template.CodeGenerationPath);
        }
    }
}
#>